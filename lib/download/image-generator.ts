/**
 * Image Generator Utility
 * Generates image reports from performance data using html2canvas
 */

import html2canvas from 'html2canvas'
import { PageSpeedData } from '@/types/page-speed'

export interface ImageGeneratorOptions {
  title?: string
  url?: string
  deviceType: 'desktop' | 'mobile'
  format: 'png' | 'jpeg'
  quality?: number
  scale?: number
}

export class ImageGenerator {
  /**
   * Generate image from DOM element or create a custom report image
   */
  async generateImage(
    element: HTMLElement | null,
    data: PageSpeedData,
    options: ImageGeneratorOptions
  ): Promise<Blob> {
    if (element) {
      // Capture the existing DOM element
      return this.captureElement(element, options)
    } else {
      // Create a custom report image
      return this.createCustomReportImage(data, options)
    }
  }

  /**
   * Capture an existing DOM element as an image
   */
  private async captureElement(element: HTMLElement, options: ImageGeneratorOptions): Promise<Blob> {
    const canvas = await html2canvas(element, {
      scale: options.scale || 2,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff',
      width: element.scrollWidth,
      height: element.scrollHeight,
      scrollX: 0,
      scrollY: 0,
    })

    return new Promise((resolve) => {
      canvas.toBlob(
        (blob) => resolve(blob!),
        `image/${options.format}`,
        options.quality || 0.9
      )
    })
  }

  /**
   * Create a custom report image from performance data
   */
  private async createCustomReportImage(data: PageSpeedData, options: ImageGeneratorOptions): Promise<Blob> {
    // Create a temporary container for the report
    const container = this.createReportContainer(data, options)
    document.body.appendChild(container)

    try {
      const canvas = await html2canvas(container, {
        scale: options.scale || 2,
        backgroundColor: '#ffffff',
        width: 800,
        height: container.scrollHeight,
      })

      return new Promise((resolve) => {
        canvas.toBlob(
          (blob) => resolve(blob!),
          `image/${options.format}`,
          options.quality || 0.9
        )
      })
    } finally {
      document.body.removeChild(container)
    }
  }

  /**
   * Create a styled report container
   */
  private createReportContainer(data: PageSpeedData, options: ImageGeneratorOptions): HTMLElement {
    const container = document.createElement('div')
    container.style.cssText = `
      position: absolute;
      top: -10000px;
      left: -10000px;
      width: 800px;
      background: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 40px;
      box-sizing: border-box;
      color: #333;
      line-height: 1.6;
    `

    const performanceScore = data.lighthouseResult?.categories?.performance?.score || 0
    const scorePercent = Math.round(performanceScore * 100)

    container.innerHTML = `
      <div style="text-align: center; border-bottom: 3px solid #007acc; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="color: #007acc; font-size: 32px; margin: 0 0 15px 0; font-weight: bold;">Performance Report</h1>
        <div style="font-size: 16px; color: #666;">
          <strong>URL:</strong> ${options.url || 'N/A'}<br>
          <strong>Device:</strong> ${options.deviceType.toUpperCase()}<br>
          <strong>Generated:</strong> ${new Date().toLocaleString()}
        </div>
      </div>

      <div style="margin-bottom: 40px;">
        <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Performance Overview</h2>
        <div style="text-align: center; margin: 20px 0;">
          <div style="display: inline-block; background: ${this.getScoreColor(performanceScore)}; color: white; padding: 15px 30px; border-radius: 8px; font-size: 20px; font-weight: bold;">
            Overall Performance Score: ${scorePercent}/100
          </div>
        </div>
        <p style="text-align: center; font-size: 16px; margin: 20px 0;">
          <strong>Status:</strong> ${this.getScoreInterpretation(performanceScore)}
        </p>
      </div>

      ${this.generateMetricsHTML(data)}
      ${this.generateOpportunitiesHTML(data)}
      ${this.generateDiagnosticsHTML(data)}

      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; font-size: 14px; color: #666;">
        <p>Generated by Speed Insight on ${new Date().toLocaleDateString()}</p>
        <p>This performance report was generated using Google's PageSpeed Insights API.</p>
      </div>
    `

    return container
  }

  private generateMetricsHTML(data: PageSpeedData): string {
    if (!data.lighthouseResult?.audits) return ''

    const keyMetrics = [
      { key: 'first-contentful-paint', label: 'First Contentful Paint', abbr: 'FCP' },
      { key: 'speed-index', label: 'Speed Index', abbr: 'SI' },
      { key: 'largest-contentful-paint', label: 'Largest Contentful Paint', abbr: 'LCP' },
      { key: 'interactive', label: 'Time to Interactive', abbr: 'TTI' },
      { key: 'total-blocking-time', label: 'Total Blocking Time', abbr: 'TBT' },
      { key: 'cumulative-layout-shift', label: 'Cumulative Layout Shift', abbr: 'CLS' }
    ]

    let metricsRows = ''
    keyMetrics.forEach(({ key, label, abbr }) => {
      const audit = data.lighthouseResult!.audits[key]
      if (!audit) return

      const score = audit.score !== null && audit.score !== undefined ? audit.score : 0
      const value = audit.numericValue ?? 0
      const formattedValue = this.formatMetricValue(key, value)
      const scorePercent = Math.round(score * 100)
      const statusColor = this.getScoreColor(score)

      metricsRows += `
        <tr style="border-bottom: 1px solid #eee;">
          <td style="padding: 12px; font-weight: bold;">${label}<br><span style="font-size: 12px; color: #666;">(${abbr})</span></td>
          <td style="padding: 12px; text-align: center; font-weight: bold;">${formattedValue}</td>
          <td style="padding: 12px; text-align: center;">${scorePercent}/100</td>
          <td style="padding: 12px; text-align: center; color: ${statusColor}; font-weight: bold;">${this.getScoreStatus(score)}</td>
        </tr>
      `
    })

    return `
      <div style="margin-bottom: 40px;">
        <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Core Web Vitals</h2>
        <table style="width: 100%; border-collapse: collapse; margin: 20px 0; border: 1px solid #ddd;">
          <thead>
            <tr style="background: #f8f9fa;">
              <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">Metric</th>
              <th style="padding: 12px; text-align: center; border-bottom: 2px solid #ddd;">Value</th>
              <th style="padding: 12px; text-align: center; border-bottom: 2px solid #ddd;">Score</th>
              <th style="padding: 12px; text-align: center; border-bottom: 2px solid #ddd;">Status</th>
            </tr>
          </thead>
          <tbody>
            ${metricsRows}
          </tbody>
        </table>
      </div>
    `
  }

  private generateOpportunitiesHTML(data: PageSpeedData): string {
    if (!data.lighthouseResult?.audits) return ''

    const opportunities = Object.entries(data.lighthouseResult.audits)
      .filter(([_, audit]) => 
        audit.details?.items && 
        Array.isArray(audit.details.items) && 
        audit.details.items.length > 0 &&
        audit.score !== null &&
        audit.score !== undefined &&
        audit.score < 0.9
      )
      .sort((a, b) => {
        const aValue = a[1].details?.items?.[0]?.wastedMs || 0
        const bValue = b[1].details?.items?.[0]?.wastedMs || 0
        return bValue - aValue
      })
      .slice(0, 5)

    if (opportunities.length === 0) {
      return `
        <div style="margin-bottom: 40px;">
          <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Optimization Opportunities</h2>
          <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; padding: 20px; margin: 20px 0;">
            <p style="margin: 0; color: #155724; font-weight: bold;">✅ No optimization opportunities found. Your site is performing well!</p>
          </div>
        </div>
      `
    }

    let opportunitiesHTML = `
      <div style="margin-bottom: 40px;">
        <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Optimization Opportunities</h2>
    `

    opportunities.forEach(([key, audit], index) => {
      const wastedMs = audit.details?.items?.[0]?.wastedMs || 0
      const wastedBytes = audit.details?.items?.[0]?.wastedBytes

      opportunitiesHTML += `
        <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 20px; margin: 15px 0;">
          <h4 style="margin: 0 0 10px 0; color: #856404; font-size: 18px;">${index + 1}. ${audit.title}</h4>
          ${audit.description ? `<p style="margin: 10px 0; color: #856404;">${audit.description}</p>` : ''}
          <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; padding: 10px; margin: 10px 0;">
            <strong style="color: #155724;">Potential Savings:</strong><br>
            ${wastedMs > 0 ? `<span style="color: #155724;">• Time: ${this.formatMetricValue('time', wastedMs)}</span><br>` : ''}
            ${wastedBytes ? `<span style="color: #155724;">• Data: ${(wastedBytes / 1024).toFixed(0)} KB</span><br>` : ''}
          </div>
        </div>
      `
    })

    opportunitiesHTML += '</div>'
    return opportunitiesHTML
  }

  private generateDiagnosticsHTML(data: PageSpeedData): string {
    if (!data.lighthouseResult?.audits) return ''

    const diagnostics = Object.entries(data.lighthouseResult.audits)
      .filter(([_, audit]) => 
        audit.score !== null &&
        audit.score === 1 &&
        audit.title &&
        !["performance", "accessibility", "best-practices", "seo"].some(cat => audit.title?.toLowerCase().includes(cat))
      )
      .slice(0, 5)

    if (diagnostics.length === 0) {
      return `
        <div style="margin-bottom: 40px;">
          <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Diagnostics</h2>
          <p>No diagnostic information available.</p>
        </div>
      `
    }

    let diagnosticsHTML = `
      <div style="margin-bottom: 40px;">
        <h2 style="color: #007acc; font-size: 24px; border-bottom: 2px solid #ddd; padding-bottom: 10px;">Diagnostics</h2>
    `

    diagnostics.forEach(([key, audit]) => {
      const details = audit.displayValue || 'Passed'
      diagnosticsHTML += `
        <div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 5px; padding: 15px; margin: 10px 0; display: flex; align-items: center;">
          <span style="margin-right: 15px; font-size: 20px; color: #0c5460;">✅</span>
          <div>
            <strong style="color: #0c5460;">${audit.title}</strong><br>
            <span style="color: #0c5460; font-size: 14px;">${details}</span>
          </div>
        </div>
      `
    })

    diagnosticsHTML += '</div>'
    return diagnosticsHTML
  }

  private formatMetricValue(key: string, value: number): string {
    if (key.includes("CLS")) {
      return value.toFixed(3)
    }
    if (value >= 1000) {
      return `${(value / 1000).toFixed(2)}s`
    }
    return `${Math.round(value)}ms`
  }

  private getScoreColor(score: number): string {
    if (score >= 0.9) return '#28a745'
    if (score >= 0.5) return '#ffc107'
    return '#dc3545'
  }

  private getScoreInterpretation(score: number): string {
    if (score >= 0.9) return 'Good'
    if (score >= 0.5) return 'Needs Improvement'
    return 'Poor'
  }

  private getScoreStatus(score: number): string {
    if (score >= 0.9) return 'Good'
    if (score >= 0.5) return 'Needs Improvement'
    return 'Poor'
  }
}
